process Photon = 
{



 source = PoolSource 
  {
    # Number of events program should run
    #untracked vstring fileNames = {'file:ZSphoton50GeVRecHits100ev.root'}
    untracked vstring fileNames = {'file:/tmp/nancy/ele50GeVRecHits10ev_080.root'}	

    untracked int32 maxEvents = 10
  }



 #magnetic field
  include "Geometry/CMSCommonData/data/cmsMagneticFieldXML.cfi"



es_module = VolumeBasedMagneticFieldESProducer
{
                   double findVolumeTolerance = 0.0
                   untracked bool cacheLastVolume = true
                   untracked bool timerOn = false
}

  # for the geometry:
  # full detector geometry
  include "Geometry/CMSCommonData/data/cmsSimIdealGeometryXML.cfi"

 #--------------------------------
  # Ecalgeometry for clustering
  #--------------------------------
  es_module = EcalBarrelGeometryEP {}
  es_module = EcalEndcapGeometryEP {}
  es_module = HcalHardcodeGeometryEP {}
  es_module = CaloTowerHardcodeGeometryEP {}
  es_module = CaloGeometryBuilder {}



include "RecoEcal/EgammaClusterProducers/data/islandClusteringSequence.cff"	



  #  Photon Producer
  module photonProducer = PhotonProducer
  {

    string scProducer   =     "islandSuperClusterProducer"
    string scCollection =     "islandBarrelSuperClusterCollection"
    string photonCollection = "uncorrectedPhotonCollection"
 
  }


 #  Photon Correction Producer
  module photonCorrectionProducer = PhotonCorrectionProducer
  {

    string phoProducer   =     "photonProducer"
    string phoCollection =     "uncorrectedPhotonCollection"
    string photonCorrCollection = "correctedPhotonCollection" 
 
 
  }

 
 sequence photons = { photonProducer, photonCorrectionProducer }

 path p1 = { islandClusteringSequence, photons }
 


  module o1 = PoolOutputModule 
   { 
      untracked string fileName = "/tmp/nancy/ele50GeVPhoton100.root" 

      untracked vstring outputCommands = 
      {
        "keep *"
      }
   }
   endpath outpath = { o1 }





}


